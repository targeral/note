# JavaScript的工作原理——V8引擎内部+关于如何编写优化代码的5个技巧

## 概述

JavaScript引擎是执行JavaScript代码的程序或解释器。JavaScript引擎可以实现为标准解释器，或即时编译器，它以某种形式将JavaScript编译为字节码。

这是一个实现JavaScript引擎的热门项目列表：

* V8: 开源，由Google开发，用C ++编写
* Rhino: 由Mozilla Foundation管理，开源，完全用Java开发
* SpiderMonkey: 这是第一款支持Netscape Navigator的JavaScript引擎，现在支持Firefox
* JavaScriptCore: 开源，以Nitro销售，由Apple为Safari开发
* KJS: KDE的引擎最初是由Harri Porten为KDE项目的Konqueror Web浏览器开发的
* Chakra (JScript9) — Internet Explorer
* Chakra (JavaScript) — Microsoft Edge
* Nashorn: 开源作为OpenJDK的一部分，由Oracle Java Languages and Tool Group编写
* JerryScript: 是物联网的轻量级引擎

## 为什么V8被创造出来

由谷歌构建的V8引擎是开源的，用 C++ 编写。此引擎在Google Chrome中使用。然而，与其他引擎不同，V8也用于流行的Node.js运行时中。

V8最初旨在提高Web浏览器中JavaScript执行的性能。为了获得速度，V8将JavaScript代码转换为更高效的机器代码，而不是使用解释器的方式来解析代码。它通过实现像许多现代JavaScript引擎（如SpiderMonkey或Rhino（Mozilla））的JIT（即时）编译器，在执行时将JavaScript代码编译为机器代码。他们的主要区别是V8不产生字节码或任何中间代码。

## V8曾经有两个编译器

在V8版本5.9出现之前（今年早些时候发布），该引擎使用了两个编译器：

* full-codegen - 一个简单而快速的编译器，可以生成简单且相对较慢的机器代码。
* Crankshaft - 一种更复杂的（即时）优化编译器，可生成高度优化的代码。

V8引擎内部也使用多个线程：

* 主线程做的事你所希望做的事情：获取代码，编译代码然后执行它
* 还有一个单独的线程也用于编译，因此在而前者正在优化代码，主线程可以继续执行。
* 一个Profiler线程，它将告诉运行时我们花费大量时间在哪个方法上，以便Crankshaft可以优化它们
* 一些线程来处理垃圾收集器扫描

首次执行JavaScript代码时，V8利用full-codegen直接将解析后的JavaScript转换为机器代码而无需任何转换。这使它可以非常快速地开始执行机器代码。请注意，V8不使用中间字节码表示，因此无需解释器。

当代码运行一段时间后，探查器线程已经收集了足够的数据来告诉应该优化哪个方法。

接下来，Crankshaft优化开始于另一个线程。它将JavaScript抽象语法树转换为名为Hydrogen的高级静态单指派（SSA）表示，并尝试优化Hydrogen图。大多数优化都是在这个级别完成的。

## inlining

第一步优化叫做 inlining，通俗的将就是讲代码中的函数调用替换为该函数的主体（调用函数的代码），这个步骤使得下面的优化更有意义。

![](https://cdn-images-1.medium.com/max/1600/0*RRgTDdRfLGEhuR7U.png)

## hide class

JavaScript是一种基于原型的语言：没有类的概念并且对象是通过克隆的过程来创建的。JavaScript也是一种动态编程语言，这意味着可以在实例化后轻松地在对象中添加或删除属性。

大多数JavaScript解释器使用类似字典的结构（基于散列函数）来存储对象属性值在内存中的位置。这种结构使得在JavaScript中检索属性的值比在Java或C＃等非动态编程语言中的计算成本更高。在Java中，所有对象属性都是在编译之前由固定对象布局确定的，并且无法在运行时动态添加或删除（好吧，C＃具有动态类型，这是另一个主题）。
结果，属性值（或指向这些属性的指针）可以作为连续缓冲区存储在存储器中，每个缓冲区之间具有固定偏移量。
可以根据属性类型轻松确定偏移的长度，而在运行时可以更改属性类型的JavaScript中，这是不可能的。

由于使用字典在内存中查找对象属性的位置效率非常低，因此V8使用不同的方法：隐藏类。隐藏类的工作方式类似于Java等语言中使用的固定对象布局（类），除非它们是在运行时创建的。现在，让我们看看它们实际上是什么样的：

``` js
function Point(x, y) {
    this.x = x;
    this.y = y;
}
var p1 = new Point(1, 2);
```

一旦“new Point(1,2)”调用发生，V8将创建一个名为“C0”的隐藏类。

![](https://cdn-images-1.medium.com/max/1600/1*pVnIrMZiB9iAz5sW28AixA.png)

尚未为Point定义任何属性，因此“C0”为空。

一旦执行了第一个语句“this.x = x”（在“Point”函数内），V8将创建一个名为“C1”的第二个隐藏类，它基于“C0”。
“C1”描述了可以找到属性x的存储器中的位置（相对于对象指针）。在这种情况下，“x”存储在偏移0处，这意味着当在存储器中查看Point对象作为连续缓冲区时，第一偏移将对应于属性“x”。
V8还将使用“类转换”更新“C0”，该类转换指出如果将属性“x”添加到Point对象，则隐藏类应该从“C0”切换到“C1”。
下面的Point对象的隐藏类现在是“C1”

![](https://cdn-images-1.medium.com/max/1600/1*QsVUE3snZD9abYXccg6Sgw.png)

每次将新属性添加到对象时，旧的隐藏类都会更新为新隐藏类的转换路径。隐藏类转换很重要，因为它们允许在以相同方式创建的对象之间共享隐藏类。如果两个对象共享一个隐藏类并且同一属性被添加到它们中，则转换将确保两个对象都接收相同的新隐藏类以及随其附带的所有优化代码。

执行语句“this.y = y”时重复此过程（再次，在Point函数内，在“this.x = x”语句之后）。

创建一个名为“C2”的新隐藏类，将类转换添加到“C1”，声明如果将属性“y”添加到Point对象（已包含属性“x”），则隐藏类应更改为“C2”，Point对象的隐藏类更新为“C2”。

![](https://cdn-images-1.medium.com/max/1600/1*spJ8v7GWivxZZzTAzqVPtA.png)

隐藏类转换取决于属性添加到对象的顺序。看一下下面的代码片段：

``` js
function Point(x, y) {
    this.x = x;
    this.y = y;
}
var p1 = new Point(1, 2);
p1.a = 5;
p1.b = 6;
var p2 = new Point(3, 4);
p2.b = 7;
p2.a = 8;
```

现在，您将假设对于p1和p2，将使用相同的隐藏类和转换。
好吧，不是真的。
对于“p1”，首先添加属性“a”，然后添加属性“b”。
但是，对于“p2”，首先分配“b”，然后是“a”。
因此，作为不同转换路径的结果，“p1”和“p2”以不同的隐藏类结束。
在这种情况下，通过使用以相同的顺序初始化动态属性是比较好的方式，因为这样可以重用隐藏的类。

## inline caching

V8利用另一种技术来优化动态类型语言，称为内联缓存。内联缓存依赖于观察到对相同类型的对象的重复调用往往发生在相同类型的对象上。可以在[此处](https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches)找到有关内联缓存的深入说明。

我们将讨论内联缓存的一般概念（如果您没有时间进行上面的深入解释）。

那么它是怎样工作的？V8维护一个在最近的方法调用中作为参数传递的对象类型的缓存，并使用此信息来假设将来作为参数传递的对象类型。如果V8能够对将传递给方法的对象类型做出很好的假设，它可以绕过确定如何访问对象属性的过程，而是使用先前查找到对象的存储信息。隐藏的类。

那么隐藏类和内联缓存的概念是如何相关的呢？每当在特定对象上调用方法时，V8引擎必须执行对该对象的隐藏类的查找，以确定访问特定属性的偏移量。在将同一方法成功调用两次到同一个隐藏类之后，V8省略了隐藏类查找，只是将属性的偏移量添加到对象指针本身。对于该方法的所有未来调用，V8引擎假定隐藏类未更改，并使用先前查找中存储的偏移直接跳转到特定属性的内存地址。这大大提高了执行速度。

内联缓存也是为什么相同类型的对象共享隐藏类非常重要的原因。如果你创建两个相同类型和不同隐藏类的对象（正如我们之前的例子中所做的那样），V8将无法使用内联缓存，因为即使这两个对象属于同一类型，它们对应的隐藏类也是如此
为其属性分配不同的偏移量。

![](https://cdn-images-1.medium.com/max/1600/1*iHfI6MQ-YKQvWvo51J-P0w.png)

这两个对象基本相同，但“a”和“b”属性是按不同顺序创建的。

## 编译成机器代码

Hydrogen图优化后，Crankshaft将其降低到称为Lithium的低级别表示。大多数Lithium实现都是特定于体系结构的。寄存器分配发生在此级别。

最后，Lithium被编译成机器代码。然后发生了一些叫做OSR的事情：堆栈替换。
在我们开始编译和优化一个明显长期运行的方法之前，我们可能正在运行它。V8不会忘记，它只是慢慢执行再次使用优化版本。相反，它将转换我们拥有的所有上下文（堆栈，寄存器），以便我们可以在执行过程中切换到优化版本。这是一项非常复杂的任务，请记住，除了其他优化之外，V8最初还是编写了代码。V8并不是唯一能够做到这一点的引擎。

有一种称为去优化的保护措施可以进行相反的转换，并在发动机制造的假设不再适用的情况下恢复到非优化代码。

## 垃圾收集

对于垃圾收集，V8采用传统的标记和扫描方式来清理旧一代。标记阶段应该停止JavaScript执行。为了控制GC成本并使执行更稳定，V8使用增量标记：不是遍历整个堆，尝试标记每个可能的对象，它只走部分堆，然后恢复正常执行。下一个GC停止将从上一个堆行走停止的位置继续。这允许在正常执行期间非常短暂的暂停。如前所述，扫描方式由单独的线程处理。

## Ignition and TurboFan

随着2017年早些时候发布V8 5.9，引入了新的执行管道。这个新的管道在实际的JavaScript应用程序中实现了更大的性能提升和显着的内存节省。新的执行管道建立在Ignition，V8的解释器和TurboFan（V8的最新优化编译器）之上。
您可以在[这里](https://v8.dev/blog/launching-ignition-and-turbofan)查看V8团队关于该主题的博客文章。自从V8的5.9版本问世以来，V8已经不再使用全代码生成和Crankshaft（自2010年以来为V8提供服务的技术），因为V8团队一直在努力跟上新的JavaScript语言功能并且这些功能需要优化。这意味着整体V8将具有更简单，更易维护的架构。

这些改进只是一个开始。新的Ignition和TurboFan管道为进一步优化铺平了道路，这些优化将在未来几年内提升JavaScript性能并缩小V8在Chrome和Node.js中的占用空间。最后，这里有一些关于如何编写优化良好的JavaScript的提示和技巧。您可以从上面的内容轻松地推导出这些内容，但是，这里有一个为方便起见的摘要：

## How to write optimized JavaScript

1. 对象属性的顺序：始终以相同的顺序实例化对象属性，以便可以共享隐藏的类和随后优化的代码。
2. 动态属性：在实例化之后向对象添加属性将强制隐藏类更改并减慢为先前隐藏类优化的任何方法。所以最好在其构造函数中分配所有对象的属性。
3. 方法：重复执行相同方法的代码将比仅执行一次许多不同方法的代码运行得更快（由于内联缓存）。
4. 数组：避免产生稀疏数组。其中没有每个元素的稀疏数组是哈希表。这种数组中的元素访问起来更加昂贵。另外，尽量避免预先分配大型数组。最好是通过动态增长。最后，不要删除数组中的元素。它会产生稀疏数组。
5. 标记值：V8表示32位的对象和数字。它使用一个位来知道它是一个对象（flag = 1）还是一个称为SMI（SMall Integer）的整数（flag = 0），因为它的31位。然后，如果数值大于31位，V8将对该数字进行选择，将其变为双精度并创建一个新对象以将数字放入其中。尝试尽可能使用31位带符号的数字，以避免对JS对象进行昂贵的装箱操作。

## link

https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e